© Nicolas Modrzyk 2018 Nicolas ModrzykJava Image Processing Recipes[https://doi.org/10.1007/978-1-4842-3465-5_1](https://doi.org/10.1007/978-1-4842-3465-5_1)

# 1.JavaVM 上的 OpenCV

Nicolas Modrzyk<sup class="calibre11">[1](#Aff2) </sup> (1)Tokyo, Japan  

几年前，在去上海的旅途中，我的一个非常好的朋友在 OpenCV 上给我买了一本大部头的书。它有大量的摄影操作、实时视频分析样本和非常有吸引力的深入解释，我迫不及待地想在我的本地环境中运行这些东西。

你可能知道，OpenCV 代表开源计算机视觉；这是一个开源库，为您提供了高级成像算法的即用型实现，从简单易用但高级的图像操作到形状识别和实时视频分析间谍功能。

OpenCV 的核心是名为 Mat 的多维矩阵对象。在这本书里，Mat 将会是我们最好的朋友。输入对象是 Mat，操作在 Mat 上运行，我们工作的输出也要 Mat。

尽管 Mat 将成为我们最好的朋友，但它是一个 C++对象，因此，它并不是最容易带去展示的朋友。无论你带他去哪里，你都必须重新编译，安装，并且对新环境非常温和。

但是垫子可以包装。

即使 Mat 是本地的(即本地运行)，他也可以被打扮成在 Java 虚拟机上运行，而几乎没有人会注意到。

第一章希望向您介绍如何使用 OpenCV 和 Java 虚拟机的一些主要语言，当然是 Java，但也包括更容易阅读的 Scala 和 Google 大肆宣传的 Kotlin。

要以相似的方式运行所有这些不同的语言，您将首先获得(re-？)介绍了一个名为 leiningen 的 Java 构建工具，然后您将继续使用它来使用简单的 OpenCV 函数。

这第一章的道路将把你带到类似的基于 JVM 的语言 Clojure 的门口，它将为你的 OpenCV 代码提供巨大创造力的即时视觉反馈。那将是第二章的内容。

## 1.1 莱宁根入门

### 问题

您还记得“编写一次，随处运行”这句名言，您希望编译 Java 代码，并在不同的机器上以简单和可移植的方式运行 Java 程序。显然，您总是可以使用普通的 javac 命令来编译 Java 代码，并在命令行上使用纯 Java 来运行您编译的代码，但是我们已经进入 21 世纪了，嘿，您正在寻找更多的东西。

无论使用哪种编程语言，手动设置工作环境都是一项艰巨的任务，当您完成后，很难与其他人共享。

使用构建工具，您可以用简单的方式定义处理项目所需的内容，并让其他用户快速入门。

您想从一个易于使用的构建工具开始。

### 解决办法

Leiningen 是一个构建工具，主要针对 JavaVM。在这个意义上，它与其他著名的类似(还记得吗？蚂蚁，(哦，我的上帝)Maven，和(它曾经工作)Gradle。

一旦 leiningen 命令安装完毕，您就可以使用它来创建基于模板的新 JavaVM 项目，并运行它们，而不会遇到通常的麻烦。

这个食谱展示了如何快速安装 Leiningen 并使用它运行你的第一个 Java 程序。

### 它是如何工作的

首先，您只需在需要的地方安装 Leiningen，然后用它创建一个空白的 Java 项目。

### 注意

安装 Leiningen 需要在您的机器上安装 Java 8。还要注意的是，由于 Java 9 通过打破当前的解决方案来解决老问题，我们现在将选择保留 Java 8。

#### 安装 Leiningen 雷宁根

Leiningen 网站本身是托管的，可以在

[https://leiningen.org/](https://leiningen.org/)

在 Leiningen 页面的顶部，您可以找到自己手动安装该工具的四个简单步骤。

So here it goes, on macOS and Unix :

1.  1.下载 lein [脚本](https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein)
    *   [https://raw . githubusercontent . com/technomancy/leiningen/stability/bin/lein](https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein)网站

2.  2.

    将它放在您的 shell 可以找到它的$PATH 中(例如，~/bin)

3.  3.

    将其设置为可执行(chmod a+x ~/bin/lein)

4.  4.

    从终端 lein 运行它，它将下载自安装包

    在 Windows 上:

5.  1.下载 lein.bat 批处理脚本
    *   [https://raw . githubusercontent . com/technomancy/leiningen/stable/bin/lein . bat](https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein.bat)

6.  2.

    使用管理员权限将它放在 C:/Windows/System32 文件夹中

7.  3.

    打开一个命令提示符并运行它，lein，它将下载自安装包

在 Unix 上，您几乎总是可以使用包管理器。macOS 上的 Brew 有一个给莱宁根的包。

在 Windows 上，也有一个不错的 Windows installer，位于[https://djpowell.github.io/leiningen-win-installer/](https://djpowell.github.io/leiningen-win-installer/)。

如果你是巧克力迷，Windows 也有巧克力套装:[https://chocolatey.org/packages/Lein](https://chocolatey.org/packages/Lein)。

如果您在终端或命令提示符下成功完成了安装过程，您应该能够检查已安装工具的版本。在第一次运行时，Leiningen 下载它自己的内部依赖项，但是任何其他后续运行通常会很快。

NikoMacBook% lein -v   Leiningen 2.7.1 on Java 1.8.0_144 Java HotSpot(TM) 64-Bit Server VM

#### 用 Leiningen 创建一个新的 OpenCV-Ready Java 项目

Leiningen 主要围绕一个名为 **project.clj** **，**的文本文件工作，这些项目的元数据、依赖项、插件和设置在一个简单的映射中定义。

当您在项目上执行调用 lein 命令的命令时，lein 将查看 project.clj 以找到它需要的关于该项目的相关信息。

Leiningen 附带了现成的项目模板，但是为了正确理解它们，让我们先一步一步地看一个例子。

For a leiningen Java project, you need two files:

*   描述项目的文件 project.clj

*   一个包含一些 Java 代码的文件，这里是 Hello.java

第一个项目的简单目录结构如下所示:

. ├── java │   └── Hello.java └── project.clj 1 directory, 2 files

为了省心，我们将保持第一个 Java 示例的代码非常简单。

public class Hello {     public static void main(String[] args) {             System.out.println("beginning of a journey");     } }

现在让我们更详细地看看名为 project.clj 的文本文件的内容:

(defproject hellojava "0.1"   :java-source-paths ["java"]   :dependencies [[org.clojure/clojure "1.8.0"]]   :main Hello)

这实际上是 Clojure 代码，但让我们简单地把它看作一种领域特定语言(DSL)，一种用简单的术语描述项目的语言。

For convenience, each term is described in Table [1-1](#Tab1).Table 1-1

Leiningen 项目元数据

<colgroup class="calibre18"><col class="tcol"> <col class="tcol"></colgroup> 
| 

单词

 | 

使用

 |
| --- | --- |
| Defproject | 定义项目的入口点 |
| 你好 java | 项目的名称 |
| Zero point one | 描述版本的字符串 |
| :java 源路径 | 相对于项目文件夹的目录列表，您将在其中放置 Java 代码文件 |
| :依赖关系 | 运行项目所需的外部库及其版本的列表 |
| [[org.clojure/clojure "1.8.0"]] | 默认情况下，该列表包含 Clojure，运行 leiningen 需要它。稍后您将把 OpenCV 库放在这里 |
| :主 | 默认情况下将执行的 Java 类的名称 |

现在继续创建前面的目录和文件结构，并相应地复制粘贴每个文件的内容。

完成后，运行您的第一个 leiningen 命令:

lein run

根据您的环境，该命令将在终端或控制台上生成以下输出。

Compiling 1 source files to /Users/niko/hellojava/target/classes beginning of a journey

呜呼！旅程开始了！但是，等等，刚才发生了什么？

这涉及到一点魔法。leiningen run 命令将使 leiningen 执行一个编译好的 Java 类 main 方法。要执行的类是在项目的元数据中定义的，正如您所记得的，应该是 **Hello** 。

在执行 Java 编译的类之前，需要…编译它。默认情况下，Leiningen 在执行 run 命令之前进行编译，因此这就是“正在编译…”消息的来源。

在这个过程中，您可能已经注意到在您的项目文件夹中创建了一个目标文件夹，其中有一个 classes 文件夹和一个 Hello.class 文件。

. ├── dev ├── java │   └── Hello.java ├── project.clj ├── src ├── target │   ├── classes │   │   ├── Hello.class

默认情况下，编译后的 Java 字节码放在 target/classes 文件夹中，然后将同一个目标文件夹添加到 Java 执行运行时(classpath)中。

随后是由“lein run”触发的执行阶段，执行来自 Hello 类的 main 方法的代码块；然后打印出消息。

beginning of a journey.

您可能会问:“如果我有多个 Java 文件，并且想运行一个不同于主文件的文件，该怎么办？”

这是一个非常有意义的问题，因为在第一章中，您可能会多次这样做，以编写和运行不同的代码示例。

假设您在同一个 Java 文件夹中的一个名为 Hello2.java 的文件中编写了第二个 Java 类，以及一些更新的旅程内容。

import static java.lang.System.out; public class Hello2 {     public static void main(String[] args) {             String[] text = new String[]{                     "Sometimes it's the journey that ",                     "teaches you a lot about your destination.",                     "--",                     "- Drake"};             for(String t : text) out.println(t);     } }

要从 Hello2.java 文件中运行这个 main 方法，可以使用可选的–m 选项调用 lein run，其中 m 代表 main，然后是要使用的主 Java 类的名称。

lein run –m Hello2

这将为您提供以下输出:

Compiling 1 source files to /Users/niko/hellojava/target/classes Sometimes it's the journey that teaches you a lot about your destination. -- - Drake

太好了。有了这些说明，您现在已经了解了足够的知识，可以继续运行您的第一个 OpenCV Java 程序了。

## 1.2 编写您的第一个 OpenCV Java 程序

### 问题

您希望使用 Leiningen 来设置一个 Java 项目，在这里您可以直接使用 OpenCV 库。

您希望利用 opencv 运行 Java 代码，但是您已经感到头疼了(当您自己编译 OpenCV 包装器时)，所以您希望使这一步尽可能简单。

### 解决办法

莱宁根的食谱 1-1 帮助你完成所有基本的设置。从那里，您可以添加对 OpenCV C++库及其 Java 包装器的依赖。

### 它是如何工作的

对于第一个 OpenCV 示例，我们将使用 Leiningen 项目模板进行设置，其中已经为您定义了 project.clj 文件和项目文件夹。Leiningen 项目模板不必单独下载，并且可以使用 Leiningen 的集成 new 命令来创建新项目。

为了在您的本地机器上创建这个项目，在命令行中，让我们调用 lein 的命令。

无论是在 Windows 还是 Mac 上，该命令都会给出

lein new jvm-opencv hellocv What the preceding command basically does is

1.  1.

    创建一个名为 hellocq 的新项目文件夹

2.  2.

    基于名为 jvm-opencv 的模板，用文件夹的内容创建目录和文件

运行该命令后，将创建以下相当简单的项目文件:

. ├── java │   └── HelloCv.java └── project.clj

这看起来不太令人印象深刻，但实际上它们与前一个配方中的两个文件几乎相同:一个项目描述符和一个 Java 文件。

**project.clj** 的内容是之前的一个略微修改的版本:

(defproject hellocv "0.1.0-SNAPSHOT"   :java-source-paths ["java"]   :main HelloCv   :repositories [    ["vendredi" "http://hellonico.info:8081/repository/hellonico/"]]   :dependencies [[org.clojure/clojure "1.8.0"]                  [opencv/opencv "3.3.1"]                  [opencv/opencv-native "3.3.1"]])

你可能马上就注意到了三条你以前从未见过的新线条。

首先是 repositories 部分，它指示一个新的存储库位置来查找依赖项。这里提供的是作者的公共存储库，在这里可以找到 opencv(和其他)的定制版本。

opencv 核心依赖项和本机依赖项已经编译并上传到公共存储库中，为您提供方便。

The two dependencies are as follows:

*   中文版

*   opencv-原生

你可能会问，为什么是两个依赖关系？

其中一个依赖因素是用于 macOS、Windows 或 Linux 的 c++ opencv 代码。opencv 核心是独立于平台的 Java 包装器，它调用依赖于平台的 c++代码。

这实际上是当你自己编译 opencv 时，OpenCV 代码的交付方式。

为了方便起见，打包的 opencv-native 依赖项包含 Windows、Linux 和 macOS 的本机代码。

位于 Java 文件夹中的文件 HelloCv.java 中的 Java 代码是一个简单的 helloworld 类示例，它将简单地加载 OpenCV 本地库；其内容如下所示。

import org.opencv.core.Core; import org.opencv.core.CvType; import org.opencv.core.Mat; public class HelloCv {     public static void main(String[] args) throws Exception {         System.loadLibrary(Core.NATIVE_LIBRARY_NAME); // ①         Mat hello = Mat.eye(3,3, CvType.CV_8UC1); // ②         System.out.println(hello.dump());　// ③     } } What does the code do?

*   ①它告诉 Java 运行时通过 loadLibrary 加载原生 opencv 库。这是使用 OpenCV 时的一个必需步骤，需要在应用程序的生命周期中完成一次。

*   ②然后可以通过 Java 对象创建原生 Mat 对象。

*   Mat 基本上是一个图像容器，就像一个矩阵，这里我们告诉它的大小为 3×3:三个像素的高度，三个像素的宽度，其中每个像素都是 8UC1 类型，这是一个奇怪的名称，只表示八位(无符号)整数(8U)的一个通道(C1)。

*   ③最后，打印 mat (matrix)对象的内容。

该项目已经准备好可以像您之前所做的那样运行了，无论您在哪个平台上运行，相同的 leiningen run 命令都会完成这项工作:

NikoMacBook% lein run

命令输出如下所示。

Retrieving opencv/opencv-native/3.3.1/opencv-native-3.3.1.jar from vendredi Compiling 1 source files to /Users/niko/hellocv2/target/classes [  1,   0,   0;    0,   1,   0;    0,   0,   1]

您看到的打印的 1 和 0 是创建的矩阵的实际内容。

## 1.3 自动编译和运行代码

### 问题

虽然 lein 命令非常通用，但是您可能希望在后台启动这个过程，并在您更改代码时让代码自动运行。

### 解决办法

Leiningen 自带自动插件。一旦启用，该插件将监视文件模式的变化并触发一个命令。让我们使用它！

### 它是如何工作的

当您使用 jvm-opencv 模板创建一个项目时(见方法 1-2)，您会注意到 project.clj 文件的内容比方法中显示的稍长。实际上更像这样:

(defproject hellocv3 "0.1.0-SNAPSHOT"   :java-source-paths ["java"]   :main HelloCv   :repositories [    ["vendredi" "http://hellonico.info:8081/repository/hellonico/"]]   **:plugins [[lein-auto "0.1.3"]]**   **:auto {:default {:file-pattern #"\.(java)$"}}**   :dependencies [[org.clojure/clojure "1.8.0"]                  [opencv/opencv "3.3.1"]                  [opencv/opencv-native "3.3.1"]])

突出显示了两条额外的线。一行是在项目元数据的 a :plugins 部分添加 lein-auto 插件。

第二行是:auto 部分，它定义了文件模式来监视变化；这里，以 Java 结尾的文件将激活 auto 子命令的刷新。

让我们回到命令行，现在我们将在通常的 run 命令之前添加 auto 命令。您现在需要编写的命令如下:

lein auto run

第一次运行它时，它会给出与前一个配方相同的输出，但是增加了一些额外的行:

auto> Files changed: java/HelloCv.java auto> Running: lein run Compiling 1 source files to /Users/niko/hellocv3/target/classes [  1,   0,   0;    0,   1,   0;    0,   0,   1] auto> Completed.

好听；请注意，leiningen 命令尚未完成运行，实际上正在监听文件更改。

从那里开始，用不同大小的 Mat 对象更新 HelloCv 的 Java 代码。所以替换下面一行:

Mat hello = Mat.eye(3,3, CvType.CV_8UC1);

随着

Mat hello = Mat.eye(5,5, CvType.CV_8UC1);

更新后的代码表明 Mat 对象现在是一个 5×5 的矩阵，每个像素仍然由一个一字节的整数表示。

查看运行 leiningen 命令的终端或控制台，查看正在更新的输出:

auto> Files changed: java/HelloCv.java auto> Running: lein run Compiling 1 source files to /Users/niko/hellocv3/target/classes [  1,   0,   0,   0,   0;    0,   1,   0,   0,   0;    0,   0,   1,   0,   0;    0,   0,   0,   1,   0;    0,   0,   0,   0,   1] auto> Completed.

请注意，这次 mat 对象的打印矩阵是由五行五列组成的。

## 1.4 使用更好的文本编辑器

### 问题

到目前为止，您可能已经使用了自己的文本编辑器来输入代码，但是您想要一个稍微好一点的工作环境来使用 OpenCV。

### 解决办法

虽然这不是最终的解决方案，其他不同的环境可能对您更有效率，但我发现使用基于 Github 的 Atom 编辑器的简单设置非常有效。在实时输入代码时，这个编辑器也非常有用。

喜欢在 Atom 中工作的一个主要原因是图片可以动态地重新加载，因此当处理一个图像时，该图像的更新会自动直接反映在您的屏幕上。据我所知，这是唯一一个有这种支持的编辑器。让我们看看它是如何工作的！

### 它是如何工作的

安装基本的 Atom 编辑器应该是一件简单的事情，只需访问网站并下载软件，因此只需继续下载安装程序即可。

[https://atom.io/](https://atom.io/)

atom 不仅在默认情况下是一个很好的编辑器，而且很容易添加插件来匹配您的工作风格。

Here for OpenCV, we would like to add three plug-ins:

*   一个通用 IDE 插件

*   一个用于 Java 语言的插件，利用

*   编辑器中的最后一个终端。

The three plug-ins are shown in Figures [1-1](#Fig1), [1-2](#Fig2), and [1-3](#Fig3).![img/459821_1_En_1_Fig1_HTML.jpg](Images/459821_1_En_1_Fig1_HTML.jpg) Figure 1-1

Atom ide-ui 插件

![img/459821_1_En_1_Fig2_HTML.jpg](Images/459821_1_En_1_Fig2_HTML.jpg) Figure 1-2

Atom Java 语言插件

![img/459821_1_En_1_Fig3_HTML.jpg](Images/459821_1_En_1_Fig3_HTML.jpg) Figure 1-3

atom ide-终端插件

在底部打开的终端将允许您键入相同的“lein auto run”命令，因此您不需要单独的命令提示符或终端窗口来运行 Leiningen 的自动运行功能。让你所有的代码都写在一个窗口里。

Ideally, your Atom layout would look something like either Figure [1-4](#Fig4) or Figure [1-5](#Fig5).![img/459821_1_En_1_Fig4_HTML.jpg](Images/459821_1_En_1_Fig4_HTML.jpg) Figure 1-4

Atom IDE 标准布局

![img/459821_1_En_1_Fig5_HTML.jpg](Images/459821_1_En_1_Fig5_HTML.jpg) Figure 1-5

Atom IDE 简洁布局

Note that autocompletion for Java is now enabled through Atom’s Java plug-in too, so typing function names will show a drop-down menu of available options, as shown in Figure [1-6](#Fig6):![img/459821_1_En_1_Fig6_HTML.jpg](Images/459821_1_En_1_Fig6_HTML.jpg) Figure 1-6

Atom IDE 自动完成

最后，虽然不能实时看到图像的更新，但可以在保存文件时看到，如果你在后台打开该文件，每次保存时都会刷新，保存是通过 OpenCV 的函数 imwrite 完成的。

因此，leiningen auto run 命令在后台运行，当 Java 文件被保存时，编译/运行周期被触发，映像被更新。

Figure [1-7](#Fig7) shows how the picture onscreen is visually updated, even without a single user action (apart from file save).![img/459821_1_En_1_Fig7_HTML.jpg](Images/459821_1_En_1_Fig7_HTML.jpg) Figure 1-7

Java 文件保存时自动更新图像

你将在本章的后面看到，但是现在作为参考，这里是使用 submat 函数改变 Mat 对象的一个子部分的颜色的代码片段。

import org.opencv.core.Core; import org.opencv.core.CvType; import org.opencv.core.Mat; import org.opencv.core.Scalar; import static org.opencv.imgcodecs.Imgcodecs.imwrite; public class HelloCv {     public static void main(String[] args) {         System.loadLibrary(Core.NATIVE_LIBRARY_NAME);         Mat hello = new Mat(150,150, CvType.CV_8UC3);         hello.setTo(new Scalar(180,80,250));         Mat sub = hello.submat(0,50,0,50);         sub.setTo(new Scalar(0,0,100));                 imwrite("dev/hello.png", hello);     } }

现在，您已经有了享受 OpenCV 全部功能的设置。让我们使用它们。

## 1.5 学习 OpenCV Mat 对象的基础知识

### 问题

您将会更好地理解 OpenCV 对象矩阵，因为它是 OpenCV 框架的核心。

### 解决办法

让我们回顾一下如何创建 mat 对象，并通过几个核心示例检查它们的内容。

### 它是如何工作的

该制作方法需要与前一制作方法相同的设置。

要创建一个每个“点”只有一个通道的非常简单的矩阵，您通常会使用 Mat 类中的以下三个静态函数之一:0、eye、1。

It easier to see what each of those does by looking at each output in Table [1-2](#Tab2).Table 1-2

静态函数为每个像素创建一个通道

<colgroup class="calibre18"><col class="tcol"> <col class="tcol"> <col class="tcol"> <col class="tcol"></colgroup> 
| 

函数名

 | 

密码

 | 

使用

 | 

输出

 |
| --- | --- | --- | --- |
| 零 | 零材料(3.3，CV_8UC1) | 当您希望新的 mat 全为零时 | [0,  0,  0;0,  0,  0;0,  0,  0] |
| 眼睛 | 材质眼(3，3，CV_8UC1) | 当除了 x=y 之外都需要 0 时 | [ 1,  0,  0;0,  1,  0;0,  0,  1] |
| 二进制反码 | Mat.ones(3，3，CV_8UC1) | 当你想要所有的 1 | [ 1,  1,  1;   1,  1,  1;1,  1,  1] |
| (上述任何一项) | Mat.ones(1，1，CV_8UC3) | 每个像素有 3 个通道 | [ 1,  0,  0] |

如果您以前使用过 OpenCV(如果您还没有使用过，请相信我们)，您会记得 **CV_8UC1** 是 OpenCV 的俚语，表示每个通道八位无符号，每个像素一个通道，因此一个 3×3 的矩阵有九个值。

它的表亲 **CV_8UC3** ，正如你已经猜到的，为每个像素分配三个通道，因此一个 1×1 的 Mat 对象将有三个值。在处理红色、蓝色、绿色或 RGB 图像时，通常会使用这种类型的垫子。这也是加载图像时的默认格式。

第一个示例简单地展示了加载每像素一个通道的 Mat 对象的三种方法和加载每像素三个通道的 Mat 对象的一种方法。

import org.opencv.core.Core; import org.opencv.core.Mat; import static java.lang.System.loadLibrary; import static java.lang.System.out; import static org.opencv.core.CvType.CV_8UC1; import static org.opencv.core.CvType.CV_8UC3; public class SimpleOpenCV {     static {             loadLibrary(Core.NATIVE_LIBRARY_NAME);     }     public static void main(String[] args) {         Mat mat = Mat.eye(3, 3, CV_8UC1);         out.println("mat = ");         out.println(mat.dump());         Mat mat2 = Mat.zeros(3,3,CV_8UC1);         out.println("mat2 = ");         out.println(mat2.dump());         Mat mat3 = Mat.ones(3,3,CV_8UC1);         out.println("mat3 = " );         out.println(mat3.dump());         Mat mat4 = Mat.zeros(1,1,CV_8UC3);         out.println("mat4 = " );         out.println(mat4.dump());     } }

最后一个 Mat 对象 mat4 是每个像素包含三个通道的对象。如您所见，当您尝试转储对象时，会创建一个三零数组。

CV_8UC1 和 **CV_8UC3** 是两种最常见的每像素格式类型，但还有许多其他类型，它们在 **CvType** 类中定义。

当进行 mat-to-mat 计算时，您可能最终还需要使用每个通道的浮点值。以下是实现这一目标的方法:

Mat mat5 = Mat.ones(3,3,CvType.CV_64FC3); out.println("mat5 = " ); out.println(mat5.dump());

和输出矩阵:

mat5 = [1, 0, 0, 1, 0, 0, 1, 0, 0;  1, 0, 0, 1, 0, 0, 1, 0, 0;  1, 0, 0, 1, 0, 0, 1, 0, 0]

在许多情况下，您可能不会自己从头开始创建矩阵，而只是从文件中加载图像。

## 1.6 从文件加载图像

### 问题

你想加载一个图像文件，将它转换成一个 Mat 对象进行数字操作。

### 解决办法

OpenCV 有一个从文件中读取图像的简单函数，名为 imread。它通常只采用本地文件系统上的文件路径到映像，但也可能有一个类型参数。让我们看看如何使用不同形式的 imread。

### 它是如何工作的

imread 函数位于同名包的 Imgcodecs 类中。

它的标准用法是简单地给出文件的路径。假设你已经从谷歌搜索下载了一张小猫的图片，并存储在 **images/kittenjpg** (图 [1-8](#Fig8) )中，代码给出如下内容:

Mat mat = Imgcodecs.imread("images/kitten.jpg"); out.println("mat ="+mat.width()+" x "+mat.height()+","+mat.type()); ![img/459821_1_En_1_Fig8_HTML.jpg](Images/459821_1_En_1_Fig8_HTML.jpg) Figure 1-8

奔跑的小猫

如果找到并正确加载了小猫图像，控制台的输出中将显示以下消息:

mat =350 x 234,16

注意，如果找不到文件，不会抛出异常，也不会报告错误消息，但是加载的 Mat 对象将是空的，因此没有行也没有列:

mat =0 x 0,0

根据您的编码方式，您可能会觉得需要用大小检查来包装加载代码，以确保找到文件并正确解码图像。

也可以黑白模式加载图片(图 [1-9](#Fig9) )。这是通过向 imread 函数传递另一个参数来实现的。

Mat mat = Imgcodecs.imread(   "images/kitten.jpg",   Imgcodecs.IMREAD_GRAYSCALE); ![img/459821_1_En_1_Fig9_HTML.jpg](Images/459821_1_En_1_Fig9_HTML.jpg) Figure 1-9

灰度加载

另一个参数来自同一个 Imgcodecs 类。

在这里，im read _ gray 在加载时强制对图像进行重新编码，并将 Mat 对象转换为灰度模式。

Other options can be passed to the imread function for some specific handling of channels and depth of the image; the most useful of them are described in Table [1-3](#Tab3).Table 1-3

图像读取选项

<colgroup class="calibre18"><col class="tcol"> <col class="tcol"></colgroup> 
| 

参数

 | 

影响

 |
| --- | --- |
| im read _ REDUCED _ gray _ 2IMREAD_REDUCED_COLOR_2im read _ REDUCED _ gray _ 4IMREAD_REDUCED_COLOR_4im read _ REDUCED _ gray _ 8IMREAD_REDUCED_COLOR_8 | 将加载的图像尺寸缩小 2、4 或 8 倍。这意味着宽度和高度除以这个数。同时，指定彩色或灰度模式。灰度表示单通道灰度模式。颜色是指三通道 RGB。 |
| IMREAD_LOAD_GDAL | 使用 GDAL 驱动程序加载光栅格式的图像。 |
| IMREAD _ 灰度 | 以单通道灰度模式加载图片。 |
| im read _ ignore _ orientation-im read _ ignore _ orientation-im read _ ignore _ orientation-im read _ ignore _ orientation-im read _ ignore _ orientation-im read _ ignore _ orientation | 如果设置，不要根据 EXIF 的方向标志旋转图像。 |

Figure [1-10](#Fig10) shows what happens when the image is loaded in REDUCED_COLOR_8.![img/459821_1_En_1_Fig10_HTML.jpg](Images/459821_1_En_1_Fig10_HTML.jpg) Figure 1-10

减小尺寸装载

您可能已经注意到，用 imread 加载图像时，不需要图像格式的指示。OpenCV 根据文件中找到的文件扩展名和二进制数据的组合进行所有的图像解码。

## 1.7 将图像保存到文件中

### 问题

您希望能够使用 OpenCV 保存图像。

### 解决办法

OpenCV 有一个用于写文件的 imread 的兄弟函数，名为 imwrite，同样由 Imgcodecs 类托管。它通常只需要本地文件系统上指向存储图像位置的文件路径，但是它也可以使用一些参数来修改图像的存储方式。

### 它是如何工作的

函数 imwrite 的工作方式类似于 imread，当然它也需要 Mat 对象来存储路径。

第一个代码片段简单地保存了彩色加载的猫图像:

Mat mat = imread("images/glasses.jpg"); imwrite("target/output.jpg", mat); Figure [1-11](#Fig11) shows the content of output.jpg picture.![img/459821_1_En_1_Fig11_HTML.jpg](Images/459821_1_En_1_Fig11_HTML.jpg) Figure 1-11

磁盘上 JPEG 格式的图像

现在，您还可以在保存 mat 对象时更改格式，只需指定不同的扩展名。例如，要保存为可移植网络图形(PNG)格式，只需在调用 imwrite 时指定不同的扩展名。

Mat mat = imread("images/glasses.jpg"); imwrite("target/output.png", mat);

没有编码和疯狂的字节操作，您的输出文件确实以 PNG 格式保存。

可以给 imwrite 保存参数，最需要的是压缩参数。

For example, as per the official documentation:

*   对于 JPEG，可以使用参数 CV_IMWRITE_JPEG_QUALITY，取值范围为 0 到 100(越高越好)。默认值为 95。

*   对于 PNG，它可以是从 0 到 9 的压缩级别()。较高的值意味着较小的大小和较长的压缩时间。默认值为 3。

使用压缩参数压缩输出文件是通过另一个名为 MatOfInt 的 opencv 对象完成的，它是一个整数矩阵，或者更简单地说，是一个数组。

MatOfInt moi = new MatOfInt(CV_IMWRITE_PNG_COMPRESSION, 9); Imgcodecs.imwrite("target/output.png", mat, moi);

这将在 png 上启用压缩。通过检查文件大小，您实际上可以看到 png 文件至少小了 10%。

## 1.8 使用 Submat 裁剪图片

### 问题

您希望只保存图像的给定部分。

### 解决办法

这个简短食谱的主要重点是介绍 submat 函数。Submat 返回一个 mat 对象，它是原始对象的子矩阵或子部分。

### 它是如何工作的

We will take a cat picture and extract only the part we want with submat. The cat picture used for this example is shown in Figure [1-12](#Fig12).![img/459821_1_En_1_Fig12_HTML.jpg](Images/459821_1_En_1_Fig12_HTML.jpg) Figure 1-12

一只猫

当然，你可以用任何你喜欢的猫图片。让我们从正常读取文件开始，用 imread。

Mat mat = Imgcodecs.imread("images/cat.jpg"); out.println(mat);

正如你可能注意到的， **println** 提供了一些关于 Mat 对象本身的信息。大部分是信息性的内存寻址，所以你可以直接黑掉内存，但是它也显示了 Mat 对象是否是 submat。在这种情况下，由于这是原始图片，所以它被设置为 false。

 [ 1200*1600*CV_8UC3,   isCont=true,   **isSubmat=false**,   nativeObj=0x7fa7da5b0a50, dataAddr=0x122c63000 ] Autocompletion in the Atom editor presents you the different versions of the submat function as shown in Figure [1-13](#Fig13).![img/459821_1_En_1_Fig13_HTML.jpg](Images/459821_1_En_1_Fig13_HTML.jpg) Figure 1-13

不同参数的 Submat

现在让我们使用第一种形式的 submat 函数，其中 submat 接受开始和结束参数，每行和每列一个:

Mat submat = mat.submat(250,650,600,1000); out.println(submat);

打印该对象表明新创建的 Mat 对象确实是 submat。

Mat [ 400*400*CV_8UC3, isCont=false, **isSubmat=true**, nativeObj=0x7fa7da51e730, dataAddr=0x122d88688 ]

您可以像普通垫子一样直接在 submat 上操作，因此您可以从保存它开始。

Imgcodecs.imwrite("output/subcat.png", submat); With the range nicely adapted to the original cat picture, the output of the saved image is shown in Figure [1-14](#Fig14):![img/459821_1_En_1_Fig14_HTML.jpg](Images/459821_1_En_1_Fig14_HTML.jpg) Figure 1-14

子猫

好的一面是，您不仅可以在 submat 上操作，而且它还可以在原始 mat 对象上反射。所以如果在 submat 上对猫的脸应用模糊效果，保存整个 mat(不是 submat)，只有猫的脸看起来会模糊。看看这是如何工作的:

Imgproc.blur(submat,submat, new Size(25.0, 25.0)); out.println(submat); Imgcodecs.imwrite("output/blurcat.png", mat);

模糊是类**org . opencv . imgproc . imgproc**的一个关键函数。它将一个大小对象作为参数，指定应用模糊效果时每个像素要考虑的表面，因此大小越大，模糊效果越强。

See the result in Figure [1-15](#Fig15), where if you look carefully, only the face of the cat is actually blurred, **and** this is the exact face we saved earlier on.![img/459821_1_En_1_Fig15_HTML.jpg](Images/459821_1_En_1_Fig15_HTML.jpg) Figure 1-15

可怜的模糊猫

正如您在 submat 函数的上下文助手菜单中所看到的，还有两种获取 submat 的方法。

一种方法是使用两个范围，第一个是行范围(y 或高度)，第二个是列范围(x 或宽度)，这两个范围都是使用 range 类创建的。

Mat submat2 = mat.submat(new Range(250,650), new Range(600,1000));

另一种方法是使用矩形，首先给出左上角的坐标，然后给出矩形的大小。

Mat submat3 = mat.submat(new Rect(600, 250, 400, 400));

使用 submat 的最后一种方法是最常用的方法之一，因为它是最自然的。此外，在图片中查找对象时，可以使用该对象的边界框，该对象的类型是 Rect 对象。

请注意，正如您所看到的，更改 submat 会对底层 mat 造成附带损害。因此，如果您决定将 submat 的颜色设置为蓝色:

submat3.setTo(new Scalar(255,0,0)); Imgcodecs.imwrite("output/submat3_2.png", submat3); Imgcodecs.imwrite("output/submat3_3.png", submat2); Imgcodecs.imwrite("output/submat3_4.png", mat); Then Figure [1-16](#Fig16) shows the blue cat face of **both** submat3_2.png and submat3_3.png.![img/459821_1_En_1_Fig16_HTML.jpg](Images/459821_1_En_1_Fig16_HTML.jpg) Figure 1-16

蓝猫脸

But those changes to the submat also update the underlying mat, as shown in Figure [1-17](#Fig17)!!![img/459821_1_En_1_Fig17_HTML.jpg](Images/459821_1_En_1_Fig17_HTML.jpg) Figure 1-17

大图蓝猫脸

所以这里的想法是要小心 submat 的使用地点和时间，但大多数时候这是一种强大的图像处理技术。

## 1.9 从子 mats 创建 Mat

### 问题

您希望从零开始手动创建一个由不同子 Mat 组成的 Mat。

### 解决办法

**setTo** 和 **copyTo** 是 OpenCV 的两个重要功能。setTo 会将 mat 的所有像素的颜色设置为指定的颜色，copyTo 会将现有的 Mat 复制到另一个 Mat。使用 setTo 或 copyTo 时，您可能会使用 submats，因此只会影响主 mat 的一部分。

要使用 setTo，我们将使用 OpenCV 的标量对象定义的颜色，目前，它将使用 RGB 颜色空间中的一组值来创建。让我们看看这一切是如何运作的。

### 它是如何工作的

第一个示例将使用 setTo 创建一个由子 mat 组成的 mat，每个子 mat 都有不同的颜色。

#### 彩色提交的垫子

首先，让我们用 RGB 值来定义颜色。如上所述，颜色是使用一个标量对象创建的，有三个 int 值，每个值在 0 到 255 之间。

第一种颜色是蓝色强度，第二种是绿色强度，最后一种是红色强度。因此，要创建红色，绿色或蓝色，你把它的主要颜色值的最大强度，所以 255，其他的为 0。

看看红色、绿色和蓝色的效果如何:

Scalar RED   = new Scalar(0, 0, 255); // Blue=0, Green=0, Red=255 Scalar GREEN = new Scalar(0, 255, 0); // Blue=0, Green=255, Red=0 Scalar BLUE  = new Scalar(255, 0, 0); // Blue=255, Green=0, Red=0

为了定义青色、品红色和黄色，让我们将这些颜色视为 RGB 的补色，因此我们将其他通道的最大值设置为 255，并将主通道设置为 0。

青色与红色互补，因此红色通道值设置为 0，其他两个通道设置为 255:

Scalar CYAN    = new Scalar(255, 255, 0);

洋红色是绿色的补色，黄色是蓝色的补色。这些定义如下:

 Scalar MAGENTA = new Scalar(255, 0, 255);  Scalar YELLOW  = new Scalar(0, 255, 255);

好吧。我们已经设置好了所有的颜色；让我们用它们来创建一个所有定义的颜色的垫子。下面的 setColors 方法使用主 mat 对象并用主 RGB 颜色或互补色 CMY 填充一行。

查看如何使用带有标量颜色的 submat 上的 setTo 函数填充 submat 内容。

  static void setColors(Mat mat, boolean comp, int row) {       for(int i = 0 ; i < 3 ; i ++) {         Mat sub = mat.submat(row*100, row*100+100, i*100, i*100+100);         if(comp) {  // RGB           if(i==0) sub.setTo(RED);           if(i==1) sub.setTo(GREEN);           if(i==2) sub.setTo(BLUE);         } else {    // CMY           if(i==0) sub.setTo(CYAN);           if(i==1) sub.setTo(MAGENTA);           if(i==2) sub.setTo(YELLOW);         }       } }

然后，调用代码以三通道 RGB 颜色模式创建 mat，并填充第一行和第二行。

    Mat mat = new Mat(200,300,CV_8UC3);     setColors(mat, false, 1);     setColors(mat, true, 0);     Imgcodecs.imwrite("output/rgbcmy.jpg", mat); The result is a mat made of two rows, each of them filled with the created colored submats , as shown in Figure [1-18](#Fig18).![img/459821_1_En_1_Fig18_HTML.jpg](Images/459821_1_En_1_Fig18_HTML.jpg) Figure 1-18

彩色提交的垫子

#### 提交图片的 mat

颜色很棒，但是你可能会用到图片。第二个例子将向您展示如何使用填充了图片内容的子模板。

首先创建一个 200×200 的 mat 和两个子 mat:一个用于主 mat 的顶部，一个用于主 mat 的底部。

int width = 200,height = 200; Mat mat = new Mat(height,width,CV_8UC3); Mat top = mat.submat(0,height/2,0,width); Mat bottom = mat.submat(height/2,height,0,width);

然后，让我们创建另一个小的 Mat，方法是将一张图片加载到其中，并将其大小调整为顶部(或底部)submat 的大小。这里向您介绍了 **Imgproc** 类的 **resize** 函数。

Mat small = Imgcodecs.imread("images/kitten.jpg"); Imgproc.resize(small,small,top.size()); You are free to choose the picture, of course; for now, let’s suppose the loaded small mat is like Figure [1-19](#Fig19):![img/459821_1_En_1_Fig19_HTML.jpg](Images/459821_1_En_1_Fig19_HTML.jpg) Figure 1-19

小猫力量

然后，小猫咪贴图被复制到顶部和底部的子贴图中。

请注意，前面的调整大小步骤至关重要；复制成功是因为 small mat 和 submat 大小相同，因此复制时不会出现问题。

small.copyTo(top); small.copyTo(bottom); Imgcodecs.imwrite("output/matofpictures.jpg", mat); This gives a **matofpictures.jpg** file of two kittens as shown in Figure [1-20](#Fig20).![img/459821_1_En_1_Fig20_HTML.jpg](Images/459821_1_En_1_Fig20_HTML.jpg) Figure 1-20

双倍小猫力量

If you forget to resize the small mat, the copy fails very badly, resulting in something like Figure [1-21](#Fig21).![img/459821_1_En_1_Fig21_HTML.jpg](Images/459821_1_En_1_Fig21_HTML.jpg) Figure 1-21

小猫迷路了

## 1.10 突出显示图片中的对象

### 问题

你有一张图片，上面有一组你想突出显示的物体、动物或形状，也许是因为你想对它们进行计数。

### 解决办法

OpenCV 提供了一个名为 Canny 的著名函数，可以突出显示图片中的线条。在本章的后面你会看到如何更详细地使用 canny 现在，让我们关注使用 Java 的基本步骤。

OpenCV 的 canny 对灰度 mat 进行轮廓检测。虽然您可以让 canny 为您做这件事，但是让我们明确地将输入面板的颜色空间更改为灰色空间。

在 OpenCV 中，使用核心类中的 **cvtColor** 函数可以很容易地改变颜色空间。

### 它是如何工作的

Suppose you have a picture of tools as shown in Figure [1-22](#Fig22).![img/459821_1_En_1_Fig22_HTML.jpg](Images/459821_1_En_1_Fig22_HTML.jpg) Figure 1-22

工作中的工具

像往常一样，我们首先将图片放入垫子中:

Mat tools = imread("images/tools.jpg");

然后，我们使用 **cvtColor** 函数转换工具贴图的颜色，该函数采用一个源贴图、一个目标贴图和一个目标颜色空间。颜色空间常量位于 Imgproc 类中，并且有一个类似 **COLOR_** 的前缀。

所以要把 mat 变成黑白，可以用 **COLOR_RGB2GRAY** 常量。

cvtColor(tools, tools, COLOR_RGB2GRAY); The black-and-white picture is ready to be sent to **canny.** Parameters for the canny function are as follows:

*   源材料

*   目标垫

*   低门槛:我们将使用 150.0

*   高阈值:通常约为低阈值*2 或低阈值*3

*   光圈:3 到 7 之间的奇数值；我们将使用 3。光圈越大，找到的轮廓越多。

*   L2 梯度值，目前设置为真

Canny 使用中心像素和相邻像素的卷积矩阵来计算每个像素的梯度值。如果梯度值高于高阈值，则将其保留为边缘。如果它在两者之间，如果它有一个高梯度连接到它，它就保持不变。

现在，我们可以调用 Canny 函数。

Canny(tools,tools,150.0,300.0,3,true); imwrite("output/tools-01.png", target); This outputs a picture as shown in Figure [1-23](#Fig23):![img/459821_1_En_1_Fig23_HTML.jpg](Images/459821_1_En_1_Fig23_HTML.jpg) Figure 1-23

精巧的工具

对于眼睛、打印机和树木来说，有时可能更容易画出白色变成黑色、黑色变成白色的反转垫子。这是使用核心类中的 **bitwise_not** 函数完成的。

Mat invertedTools = tools.clone(); bitwise_not(invertedTools, invertedTools); imwrite("output/tools-02.png", invertedTools); The result is shown in Figure [1-24](#Fig24).![img/459821_1_En_1_Fig24_HTML.jpg](Images/459821_1_En_1_Fig24_HTML.jpg) Figure 1-24

倒置的 canny 工具

You can of course apply the same **Canny** processing to ever more kitten pictures . Figures [1-25](#Fig25), [1-26](#Fig26), and [1-27](#Fig27) show the same code applied to a picture of kittens.![img/459821_1_En_1_Fig25_HTML.jpg](Images/459821_1_En_1_Fig25_HTML.jpg) Figure 1-25

准备好成为精明的小猫了吗

![img/459821_1_En_1_Fig26_HTML.jpg](Images/459821_1_En_1_Fig26_HTML.jpg) Figure 1-26

机灵的小猫

![img/459821_1_En_1_Fig27_HTML.jpg](Images/459821_1_En_1_Fig27_HTML.jpg) Figure 1-27

倒置的机灵小猫

## 1.11 使用 Canny 结果作为掩码

### 问题

虽然 canny 在边缘检测方面非常出色，但另一种使用其输出的方式是作为遮罩，这会给你一个漂亮的艺术图像。

让我们试着在另一张图片上绘制一个巧妙操作的结果。

### 解决方法

执行复制操作时，可以使用所谓的掩码作为参数。遮罩是常规的单通道遮罩，因此值为 0 和 1。

当使用遮罩执行复制时，如果该像素的遮罩值为 0，则不复制源遮罩像素，如果该值为 1，则将源像素复制到目标遮罩。

### 它是如何工作的

在前面的配方中，我们从 bitwise_not 函数的结果中获得了一个新的 Mat 对象。

Mat kittens = imread("images/three_black_kittens.jpg"); cvtColor(kittens,kittens,COLOR_RGB2GRAY); Canny(kittens,kittens,100.0,300.0,3, true); bitwise_not(kittens,kittens);

如果你决定转储小猫(可能不是一个好主意，因为文件相当大……)，你会看到一堆 0 和 1；这就是面具的制作过程。

现在我们有了遮罩，让我们创建一个白色的 mat，命名为 target，作为复制函数的目标。

Mat target = new Mat(kittens.height(), kittens.width(), CV_8UC3, WHITE );

然后，我们为拷贝加载一个源，正如您所记得的，我们需要确保它的大小与拷贝操作的另一个组件的大小相同。

让我们对背景对象执行调整大小操作。

Mat bg = imread("images/light-blue-gradient.jpg"); Imgproc.resize(bg, bg, target.size());

给你。你已经准备好复制了。

bg.copyTo(target, **kittens**); imwrite("output/kittens-03.png", target); The resulting Mat is shown in Figure [1-28](#Fig28).![img/459821_1_En_1_Fig28_HTML.jpg](Images/459821_1_En_1_Fig28_HTML.jpg) Figure 1-28

蓝色背景上的小猫

现在你能回答以下问题了吗:为什么猫被画成白色？

正确答案确实是底层地垫被初始化为全白；请参见新的 Mat(…，白色)声明。当遮罩阻止复制像素时，也就是说，当该像素的值为零时，垫子的原始颜色将显示出来，这里是白色，这就是小猫在图 [1-28](#Fig28) 中以白色显示的方式。你当然可以试着用黑色的垫子，或者你选择的图片。

我们将在接下来的章节中看到更多这样的例子。

## 1.12 用轮廓检测边缘

### 问题

从 canny 操作的结果中，您可能希望找到一个可绘制轮廓的列表，并在垫子上绘制它们。

### 解决办法

OpenCV 有一组两个函数，通常与 canny 函数一起使用:这些函数是 **findContours** 和 **drawContours** 。

**寻找轮廓**拿一个垫子，在垫子上寻找边缘，或者定义形状的线条。由于原始图片可能包含大量来自颜色和亮度的噪声，您通常使用预处理图像，即应用了 canny 函数的黑白垫。

**drawContours** 获取 **findContours** 的结果，这是一个轮廓对象列表，并允许你用特定的特征来绘制它们，比如用来绘制的线条的粗细和颜色。

### 它是如何工作的

As presented in the solution, OpenCV’s findContours method takes a preprocessed picture along with other parameters:

1.  1.

    预处理的垫子

2.  2.

    将接收轮廓对象(MatOfPoint)的空列表

3.  3.

    等级席；你可以暂时忽略它，让它成为一个空垫子

4.  4.

    轮廓检索模式，例如是否创建轮廓之间的关系或返回所有轮廓

5.  5.

    用于存储轮廓的近似类型；例如，绘制所有点或仅关键定义点

首先，让我们包装原始图片的预处理，和寻找轮廓，在我们自己的自定义方法，**寻找 _** **轮廓**。

static List find_contours(Mat image, boolean onBlank) {     Mat imageBW = new Mat();     Imgproc.cvtColor(image, imageBW, Imgproc.COLOR_BGR2GRAY);     Canny(imageBW,imageBW,100.0,300.0,3, true);     List contours = new ArrayList<MatOfPoint>();     Imgproc.findContours(imageBW, contours, new Mat(),             Imgproc.RETR_LIST,             Imgproc.CHAIN_APPROX_SIMPLE);     return contours; }

该方法返回找到的轮廓列表，其中每个轮廓本身是一个点列表，或者用 OpenCV 术语来说，是一个 MatOfPoint 对象。

接下来，我们编写一个 **draw_contours** 方法，该方法将使用原始的 Mat 来找出在上一步中找到的每个轮廓的大小，以及我们希望每个轮廓被绘制的厚度。

要绘制轮廓à la opencv，通常使用 for 循环，并将要绘制的轮廓的索引赋予 drawContours 方法。

static Mat draw_contours(Mat originalMat, List contours, int thickness) {     Mat target =       new Mat(originalMat.height(), originalMat.width(), CV_8UC3, WHITE);     for (int i = 0; i < contours.size(); i++)       Imgproc.drawContours(target, contours, i, BLACK, thickness);     return target; }

太好了；这个食谱的组成部分已经写好了，所以你可以把它们付诸行动。可以用和之前一样的小猫图片作为基础图片。

Mat kittens = imread("images/three_black_kittens.jpg"); List contours = find_contours(kittens, true); Mat target = draw_contours(kittens, contours, 7); imwrite("output/kittens-contours-7.png", target); The draw_contours result is shown in Figure [1-29](#Fig29).![img/459821_1_En_1_Fig29_HTML.jpg](Images/459821_1_En_1_Fig29_HTML.jpg) Figure 1-29

小猫轮廓，厚度=7

Go ahead and change the thickness used when drawing contours . For example, with the thickness set to 3, the slightly different result, with thinner lines, is shown in Figure [1-30](#Fig30).![img/459821_1_En_1_Fig30_HTML.jpg](Images/459821_1_En_1_Fig30_HTML.jpg) Figure 1-30

小猫轮廓，厚度=3

从那里，我们可以再次使用产生的垫作为遮罩时，做背景复制。

下面的代码片段摘自前面的菜谱；该函数获取一个掩码，并使用该掩码进行复制。

    static Mat mask_on_bg(Mat mask, String backgroundFilePath) {         Mat target = new Mat(mask.height(),mask.width(),CV_8UC3,WHITE);         Mat bg = imread(backgroundFilePath);         Imgproc.resize(bg, bg, target.size());         bg.copyTo(target, mask);         return target;     } Figure [1-31](#Fig31) shows the result of a copy with the mask created while drawing contours on thickness set to 3.![img/459821_1_En_1_Fig31_HTML.jpg](Images/459821_1_En_1_Fig31_HTML.jpg) Figure 1-31

蓝色背景上的白色小猫

值得注意的是，在第三章中，你将会看到使用蒙版和背景来获得一些艺术效果的更酷的方法，但是现在，让我们来总结一下这个方法。

## 1.13 处理视频流

### 问题

您希望在视频流上使用 OpenCV 并实时进行图像处理。

### 解决办法

OpenCV 的 Java 版本提供了一个 videoio 包，特别是一个 **VideoCapture** 对象，它提供了直接从连接的视频设备读取 Mat 对象的方法。

您将首先看到如何从视频设备中检索给定大小的 Mat 对象，然后将 Mat 保存到文件中。

使用一个框架，您还将看到如何在实时图像采集中插入先前的处理代码。

### 它是如何工作的

#### 拍摄静态照片

下面介绍一下 do_still_captures 函数。需要抓取若干帧，每帧之间要等待多长时间，从哪个 camera_id 拍照。

camera_id 是连接到您机器的捕获设备的索引。您通常会使用 0，但您可能会插入并使用其他外部设备，在这种情况下，请使用相应的 camera_id。

首先创建一个 VideoCapture 对象，参数为 camera_id。

然后创建一个空白的 Mat 对象，并传递它来接收来自 **camera.read()** 函数的数据。

Mat 对象是您到目前为止使用过的标准 OpenCV Mat 对象，因此您可以轻松地应用您所学的相同变换。

现在，让我们简单地用带时间戳的文件名一个接一个地保存这些帧。

完成后，您可以使用 VideoCapture 对象上的 **release** 方法将相机返回待机模式。

看看下面的清单。

static void do_still_captures(int frames, int lapse, int camera_id) {       VideoCapture camera = new VideoCapture(camera_id);       camera.set(Videoio.CV_CAP_PROP_FRAME_WIDTH, 320);       camera.set(Videoio.CV_CAP_PROP_FRAME_HEIGHT, 240);       Mat frame = new Mat();       for(int i = 0 ; i <frames;i++) {           if (camera.read(frame)){              String filename = "video/"+new Date()+".jpg";              Imgcodecs.imwrite(filename, frame);              try {Thread.sleep(lapse*1000);}              catch (Exception e) {e.printStackTrace();}           }       }       camera.release(); }

调用新创建的函数只是填充参数，因此下面将从 ID 为 0 的设备中拍摄 10 张照片，并且在每张照片之间等待 1 秒钟。

do_still_captures(10,1,0); As is shown in Figure [1-32](#Fig32), ten pictures should be created in the video folder of the project. And, indeed, time flies; it is already past midnight.![img/459821_1_En_1_Fig32_HTML.jpg](Images/459821_1_En_1_Fig32_HTML.jpg) Figure 1-32

迷你——静止卧室的延时

#### 实时工作

好吧。因此，这里的坏消息是 OpenCV Java 包装器没有包括将 Mat 转换为 BufferedImage 的显而易见的方法，buffered image 是处理 Java 图形包中图像的实际对象。

这里不做过多的详细说明，假设您实际上需要这个 **MatToBufferedImage** 在 Java 框架中实时工作，通过将 Mat 对象转换为 BufferedImage，从而能够将其呈现为标准的 Java GUI 对象。

让我们快速编写一个方法，将 OpenCV Mat 对象转换为标准的 Java BufferedImage。

public static BufferedImage MatToBufferedImage(Mat frame) {     int type = 0;     if(frame==null) return null;     if (frame.channels() == 1) {         type = BufferedImage.TYPE_BYTE_GRAY;     } else if (frame.channels() == 3) {         type = BufferedImage.TYPE_3BYTE_BGR;     }     BufferedImage image =         new BufferedImage(frame.width(), frame.height(), type);     WritableRaster raster = image.getRaster();     DataBufferByte dataBuffer = (DataBufferByte) raster.getDataBuffer();     byte[] data = dataBuffer.getData();     frame.get(0, 0, data);     return image; }

一旦你有了这个代码块，它实际上会变得更容易，但是你仍然需要更多的代码块；扩展 Java Panel 类 JPanel 的自定义面板。

这个自定义面板，我们称之为 **MatPanel** ，是由一个字段组成的，该字段是要绘制的 Mat 对象。然后 MatPanel 以这样的方式扩展了 Java JPanel 类: **paint()** 方法现在使用您刚才看到的方法直接转换 Mat:**MatToBufferedImage**。

class MatPanel extends JPanel {     public Mat mat;     public void paint(Graphics g) {         g.drawImage(WebcamExample.MatToBufferedImage(mat), 0, 0, this);     } }

好吧。默认 OpenCV 包中不知何故丢失的代码现在已经被重新实现，您可以创建一个 Java 框架来接收 Mat 对象。

MatPanel t = new MatPanel(); JFrame frame0 = new JFrame(); frame0.getContentPane().add(t); frame0.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); frame0.setSize(320, 240); frame0.setVisible(true); frame0.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

本练习的最后一步是简单地使用类似于 **do_still_captures** 方法的代码，但不是在几帧后停止，而是编写一个永久循环来给视频流留下印象。

VideoCapture camera = new VideoCapture(0); camera.set(Videoio.CV_CAP_PROP_FRAME_WIDTH, 320); camera.set(Videoio.CV_CAP_PROP_FRAME_HEIGHT, 240); Mat frame = new Mat(); while(true){   if (camera.read(frame)){     t.mat=frame;     t.repaint();   } } Figure [1-33](#Fig33) gives a real-time view of a Japanese room at 1 am, painted in real time in a Java frame.![img/459821_1_En_1_Fig33_HTML.jpg](Images/459821_1_En_1_Fig33_HTML.jpg) Figure 1-33

Java 框架下的实时流

Obviously, the goal of this is to be able to work with the Mat object in real time, so now a good exercise for you is to write the necessary code that leads to the screenshot seen in Figure [1-34](#Fig34).![img/459821_1_En_1_Fig34_HTML.jpg](Images/459821_1_En_1_Fig34_HTML.jpg) Figure 1-34

实时清晰的图片

答案显示在下面的代码片段中，正如您已经猜到的，这是一个将已经看到的 **canny** 转换应用到从摄像机读取的 Mat 对象的简单问题。

if (camera.read(frame)){     Imgproc.cvtColor(frame,frame, Imgproc.COLOR_RGB2GRAY);     Mat target = new Mat();     Imgproc.Canny(frame,target,100.0,150.0,3,true);     t.mat=target; t.repaint(); }

## 1.14 用 Scala 编写 OpenCV 代码

### 问题

现在您可以用 Java 编写一点 OpenCV 代码了，您开始喜欢它了，但是希望使用 Scala 来减少样板代码。

### 解决办法

到目前为止，您已经完成的当前 OpenCV 设置使得运行为 JavaVM 编译的任何类变得容易。因此，如果你设法编译 Scala 类，并且有一个 Leiningen 插件专门用于此，那么其余的几乎是相同的。

也就是说，使用你目前使用的 Leiningen 设置，你只需要在几个地方更新项目元数据，在 **project.clj** 中。

这分两步进行。首先，添加 scala 编译器和库，然后更新包含 scala 代码的文件所在的目录。

### 它是如何工作的

#### 基本设置

The **project.clj** needs be updated in a few places as highlighted in the following.

*   项目名称；当然，这是可选的。

*   主类；你可以保留相同的名字，但是如果你这样做了，确保用 **lein clean** 删除旧的 Java 代码。

*   接下来，lein-zinc 插件是 Leiningen 的一体化 scala 插件，需要添加。

*   lein-zinc 插件需要在 lein 执行编译之前被触发，因此我们将在项目元数据的 **prep-tasks** 键中添加一个步骤。prep-tasks 键负责定义在类似命令运行之前需要执行的任务。

*   最后，scala 库依赖项被添加到 dependencies 键中。

生成的 project.clj 文件可以在下面找到。

(defproject **opencv-scala-fun** "0.1.0-SNAPSHOT"   **:java-source-paths ["scala"]**   :repositories [["vendredi"          "http://hellonico.info:8081/repository/hellonico/"]]   **:main SimpleOpenCV**   :plugins [   **[lein-zinc "1.2.0"]**   [lein-auto "0.1.3"]]   **:prep-tasks ["zinc" "compile"]**   **:auto {:default {:file-pattern #"\.(scala)$"}}**   :dependencies [    [org.clojure/clojure "1.8.0"]    **[org.scala-lang/scala-library "2.12.4"]**    [opencv/opencv "3.3.1"]    [opencv/opencv-native "3.3.1"] ]) Your new project file setup for scala should look something like the structure shown in Figure [1-35](#Fig35).![img/459821_1_En_1_Fig35_HTML.jpg](Images/459821_1_En_1_Fig35_HTML.jpg) Figure 1-35

Scala 项目目录结构

正如你所看到的，Java 设置没有太大的变化，但是要确保你的源文件现在在 scala 文件夹中。

为了确认所有的东西都就位并正确设置，让我们再次尝试一个简单的 OpenCV 例子，但是这次是在 Scala 中。

您将需要像之前在 Java 示例中所做的那样加载 OpenCV 本地库。如果您将 loadLibrary 调用放在 scala 对象定义中的任何地方，它将被视为 JVM 的静态调用，并将在加载新的 Scala 编写的 SimpleOpenCV 类时加载库。

其余的代码是 Java 代码的直接翻译。

import org.opencv.core._ import org.opencv.core.CvType._ import clojure.lang.RT.loadLibrary object SimpleOpenCV {     loadLibrary(Core.NATIVE_LIBRARY_NAME)     def main(args: Array[String]) {       val mat = Mat.eye(3, 3, CV_8UC1)       println("mat = \n" + mat.dump())     } }

编译前面的代码时，一些 Java 字节码是从 scala 源代码中生成的，在目标文件夹中，就像处理 Java 代码一样。

因此，您可以像使用 Java 一样运行 scala 代码，或者使用命令:

lein auto run

控制台中的输出显示了预期的 OpenCV 3x3 眼罩被转储到屏幕上。

NikoMacBook% lein auto run auto> Files changed: scala/DrawingContours.scala, scala/SimpleOpenCV.scala, scala/SimpleOpenCV1.scala, scala/SimpleOpenCV2.scala, scala/SimpleOpenCV3.scala auto> Running: lein run scala version:  2.12.4 sbt   version:  0.13.9 fork java?      false [warn] Pruning sources from previous analysis, due to incompatible CompileSetup. mat = [  1,   0,   0;    0,   1,   0;    0,   0,   1] auto> Completed. An overview of the updated setup in Atom for scala can be found in Figure [1-36](#Fig36).![img/459821_1_En_1_Fig36_HTML.jpg](Images/459821_1_En_1_Fig36_HTML.jpg) Figure 1-36

Scala 设置

#### 模糊不清的

同意，第一个 Scala 例子有点太简单了，所以现在让我们使用一些 Scala 中 OpenCV 模糊效果的力量。

import clojure.lang.RT.loadLibrary import org.opencv.core._ import org.opencv.imgcodecs.Imgcodecs._ import org.opencv.imgproc.Imgproc._ object SimpleOpenCV2 {   loadLibrary(Core.NATIVE_LIBRARY_NAME)   def main(args: Array[String]) {     val neko = imread("images/bored-cat.jpg")     imwrite("output/blurred_cat.png", blur_(neko, 20))   }   def blur_(input: Mat, numberOfTimes:Integer) : Mat = {     for(_ <- 1 to numberOfTimes )       blur(input, input, new Size(11.0, 11.0))     input   } }

如您所见，连续多次调用模糊效果，以在同一个 Mat 对象上增量应用模糊效果。

And the bored cat from Figure [1-37](#Fig37) can be blurred to a blurred bored cat in Figure [1-38](#Fig38).![img/459821_1_En_1_Fig37_HTML.jpg](Images/459821_1_En_1_Fig37_HTML.jpg) Figure 1-37

无聊的猫

![img/459821_1_En_1_Fig38_HTML.jpg](Images/459821_1_En_1_Fig38_HTML.jpg) Figure 1-38

模糊又无聊

当然，您已经在本地机器上尝试过了，并且发现 scala 设置有两个非常好的地方。

编译时间减少了一点，而且实际上可以更快地看到 OpenCV 代码的运行。scala 编译器似乎从增量代码变更中决定了所需的编译步骤。

此外，静态导入，即使它们已经存在于 Java 中，也似乎更自然地与 scala 设置集成在一起。

#### 坎尼效应

为了进一步减少样板代码，Scala 不仅简化了类的导入，还简化了方法的导入。

scala 配方中的第三个例子将展示如何在改变加载的 OpenCV Mat 的颜色空间后应用 canny 变换。

代码相当干净；唯一遗憾的是，OpenCV 函数 **vconcat** 需要一个 java.util.Array，并且不能将原生 scala 对象作为参数，因此您需要使用 **Arrays.asList** Java 函数来代替。

import java.util.Arrays import org.opencv.core._ import org.opencv.core.CvType._ import org.opencv.core.Core._ import org.opencv.imgproc.Imgproc._ import org.opencv.imgcodecs.Imgcodecs._ import clojure.lang.RT.loadLibrary object SimpleOpenCV3 {     loadLibrary(Core.NATIVE_LIBRARY_NAME)     def main(args: Array[String]) {       val cat = imread("images/cat3.jpg")       cvtColor(cat,cat,COLOR_RGB2GRAY)       Canny(cat,cat, 220.0,230.0,5,true)       val cat2 = cat.clone()       bitwise_not(cat2,cat2)       val target = new Mat       vconcat(Arrays.asList(cat,cat2), target)       imwrite("output/canny-cat.png", target)     } } The canny parameters have been taken to output something in the simple art space, and this time it’s not really effective to find out edges at all. Figures [1-39](#Fig39) and [1-40](#Fig40) show the before/after of the canny effect on a loaded cat image.![img/459821_1_En_1_Fig39_HTML.jpg](Images/459821_1_En_1_Fig39_HTML.jpg) Figure 1-39

不怕 Scala

![img/459821_1_En_1_Fig40_HTML.jpg](Images/459821_1_En_1_Fig40_HTML.jpg) Figure 1-40

我已经被警告了

为 Java 编写的绘制等高线示例也已经移植到 Scala，并且可以在本书的示例源代码中找到；目前，这是留给读者的一个简单练习。

## 1.15 用 Kotlin 编写 OpenCV 代码

### 问题

用 Scala 编写 OpenCV 转换非常令人兴奋，但是现在 Google 正在推动 Kotlin，你可能会像新手一样用 Kotlin 编写 OpenCV 代码。

### 解决方法

当然，还有雷宁根的 Kotlin 插件。至于 scala 设置，您需要更新项目元数据，再次更新文件 **project。** **clj**

您通常需要添加 Kotlin 插件，以及 Kotlin 源文件的路径。

### 它是如何工作的

#### 基本设置

project.clj 文件中需要更新的地方与 scala 设置所需的更新非常相似，并在下面的代码片段中突出显示。

(defproject **opencv-kotlin-fun** "0.1.0-SNAPSHOT"   :repositories [    ["vendredi" "http://hellonico.info:8081/repository/hellonico/"]]   :main First   :plugins [    **[hellonico/lein-kotlin "0.0.2.1"]**    [lein-auto "0.1.3"]]   **:prep-tasks ["javac" "compile" "kotlin" ]**   **:kotlin-source-path "kotlin"**   **:java-source-paths ["kotlin"]**   **:auto {:default {:file-pattern #"\.(kt)$"}}**   :dependencies [    [org.clojure/clojure "1.8.0"]    [opencv/opencv "3.3.1"]    [opencv/opencv-native "3.3.1"]])

因为 Kotlin 类是由插件透明地编译成 JavaVM 字节码的，所以您可以像到目前为止所做的那样引用编译后的类。

显然，第一个测试是要找出您是否可以加载一个 Mat 对象并转储它的 0 和 1 值。

以下简短的 Kotlin 片段就是这样做的。

import org.opencv.core.* import org.opencv.core.CvType.* import clojure.lang.RT object First {     @JvmStatic fun main(args: Array<String>) {         RT.loadLibrary(Core.NATIVE_LIBRARY_NAME)         val mat = Mat.eye(3, 3, CV_8UC1)         println(mat.dump())     } }

在运行通常的 Leiningen run 命令之前，First.kt 文件应该位于 Kotlin 文件夹中。

lein auto run –m First

命令输出也是必要的，它显示了正确创建并打印在控制台上的 OpenCV 对象。

auto> Files changed: kotlin/Blurring.kt, kotlin/ColorMapping.kt, kotlin/First.kt, kotlin/ui/World0.kt, kotlin/ui/World1.kt, kotlin/ui/World2.kt, kotlin/ui/World3.kt, kotl in/ui/World4.kt auto> Running: lein run -m First [  1,   0,   0;    0,   1,   0;    0,   0,   1] auto> Completed.

这很简单。让我们看看如何用 Kotlin 和 OpenCV 做一些稍微复杂的事情。

#### 颜色变换

下面的新例子展示了如何使用 **Imgproc** 的 **applyColorMap** 函数在不同的颜色贴图之间切换，现在所有的东西都用 Kotlin 编码。

import org.opencv.core.* import org.opencv.imgproc.Imgproc.* import org.opencv.imgcodecs.Imgcodecs.* object ColorMapping {     @JvmStatic fun main(args: Array<String>) {         System.loadLibrary(Core.NATIVE_LIBRARY_NAME)         val mat = imread("resources/kitten.jpg")         applyColorMap(mat,mat,COLORMAP_WINTER)         imwrite("output/winter.png", mat)         applyColorMap(mat,mat,COLORMAP_BONE)         imwrite("output/bone.png", mat)         applyColorMap(mat,mat,COLORMAP_HOT)         val mat2 = mat.clone()         val newSize =               Size((mat.width()/2).toDouble(),(mat.height()/2).toDouble())         resize(mat2,mat2,newSize)         imwrite("output/hot.png", mat2)     } }

您可能知道，Kotlin 中的构造函数调用不需要冗长的 **new** 关键字，就像在 Scala 中一样，方法可以静态导入。

You can see this in action and with the original input image in Figure [1-41](#Fig41).![img/459821_1_En_1_Fig41_HTML.jpg](Images/459821_1_En_1_Fig41_HTML.jpg) Figure 1-41

猫准备好了吗

You can see three files being created; those three output files are shown in Figures [1-42](#Fig42), [1-43](#Fig43), and [1-44](#Fig44).![img/459821_1_En_1_Fig42_HTML.jpg](Images/459821_1_En_1_Fig42_HTML.jpg) Figure 1-42

骨猫

![img/459821_1_En_1_Fig43_HTML.jpg](Images/459821_1_En_1_Fig43_HTML.jpg) Figure 1-43

冬天的猫

![img/459821_1_En_1_Fig44_HTML.jpg](Images/459821_1_En_1_Fig44_HTML.jpg) Figure 1-44

热猫，改变了它的大小

在 Kotlin 中，正确的类型转换似乎有点困难，但是代码还是非常紧凑，就像在 Scala 中一样，删除了相当多的样板代码。

#### 用户界面

您可能想使用 Kotlin 的一个主要原因是因为它有令人难以置信的 tornadofx 库，这使得在 JVM 底层 GUI 框架 JavaFX 中编写简单的用户界面更加容易。

像这样的小应用程序非常有用，可以让用户有机会更改 OpenCV 参数并实时看到结果。

##### Kotlin Setup

可以将 tornadofx 库添加到 dependencies 部分的 **project.clj** 文件中，如下所示:

(defproject opencv-kotlin-fun "0.1.0-SNAPSHOT"   ...   :dependencies [    [org.clojure/clojure "1.8.0"]    [opencv/opencv "3.3.1"]    [no.tornado/tornadofx "1.7.11"]    [opencv/opencv-native "3.3.1"]])

因为这个食谱的目标是给你创造性的想法，我们不打算深入学习如何写 Kotlin 代码和用 tornadofx 写 Kotlin 代码。但是您将很快喜欢上几个 Kotlin 示例，了解如何将它们与 OpenCV 集成。

接下来的第一个例子向您展示了如何引导您的 Kotlin 代码在一个帧中显示一幅图像。

##### 虚拟用户界面

A simple tornadofx application basically follows a given Launcher ➤ App ➤ View structure, as shown in the graph of Figure [1-45](#Fig45).![img/459821_1_En_1_Fig45_HTML.gif](Images/459821_1_En_1_Fig45_HTML.gif) Figure 1-45

Tornadofx 应用程序图表

With this diagram in mind, we need to create three classes .

*   HelloWorld0:用户界面应用程序的主视图

*   MyApp0:要发送到 JavaFX 启动器的 JavaFX 应用程序对象

*   World0:仅创建一次的主类，因此使用对象而不是类来定义它，以启动基于 JVM 的应用程序

A view in tornadofx is made of a root panel, which can be customized with the javafx widgets as you want.

*   下面的代码创建了一个视图，该视图由嵌入了 imageview 小部件的图像组成。

*   imageview 的图像大小在定义小部件的块中设置。

*   视图初始化在 **init {..}** 块，而根对象，由于不能再次实例化，正在用神奇的函数**搭配**。

package ui; import tornadofx.* import javafx.application.Application import javafx.scene.layout.* class HelloWorld0 : View() {     override val root = VBox()     init {         with(root) {             imageview("cat.jpg") {               fitHeight = 160.0               fitWidth = 200.0             }         }     } }

剩下的代码是标准的 tornadofx/javafx 样板文件，用于正确启动基于 javafx 的应用程序。

class MyApp0: App(HelloWorld0::class) object World0 {     @JvmStatic fun main(args: Array<String>) {             Application.launch(MyApp0::class.java, *args)     } }

在自动模式下用 leiningen 运行前面的代码，就像到目前为止用

lein auto run –m ui.World0 And a graphical frame should show up on your screen (Figure [1-46](#Fig46)).![img/459821_1_En_1_Fig46_HTML.jpg](Images/459821_1_En_1_Fig46_HTML.jpg) Figure 1-46

帧中的图像

实际上，代码和框架略有不同。在根块中设置了一个标题，并在适当的位置添加了以下代码片段。你应该找出在哪里！

title = "Image in Frame"

##### 带有反应式按钮的用户界面

下一个示例建立在前一个示例的基础上，并添加了一个按钮，当单击该按钮时，内部计数器的值会递增，然后该计数器的值会实时显示在屏幕上。

可以使用 **SimpleIntegerProperty** 或 **javafx.beans** 包中的 SimpleXXXProperty 来创建反应值。

然后，该反应值可以绑定到一个小部件，在接下来的示例中，它将绑定到一个标签，因此标签的值等于属性的值。

按钮是一个简单的 UI 小部件，您可以在其上定义操作处理程序。处理程序代码可以在块内部，也可以在不同的 Kotlin 函数中。

有了目标和解释，让我们来看下面的代码片段。

package ui; import tornadofx.* import javafx.application.Application import javafx.scene.layout.* import javafx.beans.property.SimpleIntegerProperty import javafx.geometry.Pos class CounterView : View() {   override val root = BorderPane()   **val counter = SimpleIntegerProperty()**   init {     title = "Counter"     with (root) {       style {         padding = box(20.px)       }       center {         vbox(10.0) {           alignment = Pos.CENTER           label() {             **bind(counter)**             style { fontSize = 25.px }           }           **button**("Click to increment") {             **action {increment()}** }}}}}   **fun increment() {counter.value += 1}** } class CounterApp : App(CounterView::class) object Counter {   @JvmStatic fun main(args: Array<String>) {     Application.launch(CounterApp::class.java, *args)   } } The result of running the counter application is shown in Figure [1-47](#Fig47).![img/459821_1_En_1_Fig47_HTML.jpg](Images/459821_1_En_1_Fig47_HTML.jpg) Figure 1-47

简单的计数器应用程序

And after a few clicks on the beautiful button, you will get something as in Figure [1-48](#Fig48).![img/459821_1_En_1_Fig48_HTML.jpg](Images/459821_1_En_1_Fig48_HTML.jpg) Figure 1-48

点击几个按钮来增加计数器

##### 模糊应用

嗯，这很酷，但它看起来像是一门创建 GUI 的课程，与 OpenCV 没有太大关系。

没错。

因此，这最后一个 Kotlin 应用程序建立在前面两个例子的基础上，并展示了如何构建一个模糊应用程序，其中模糊量由反应属性设置。

你必须在 Java 领域的 Image 对象和 OpenCV 领域的 Mat 对象之间来回切换。下面的例子展示了一种快速的方法，通过使用 OpenCV 中的 **imencode** 函数，将 Mat 对象编码成字节，而不是将所有这些转换成文件。

模糊应用程序有一个 SimpleObjectProperty 类型的 val，它随着图形视图的更新而改变。

较长的导入列表有点烦人，但是对于您自己的定制应用程序，您可能不需要太多的导入列表。

package ui.cv; import org.opencv.core.* import org.opencv.imgproc.Imgproc.* import org.opencv.imgcodecs.Imgcodecs.* import clojure.lang.RT import tornadofx.* import javafx.application.Application import javafx.scene.layout.* import javafx.scene.paint.Color import javafx.application.Platform import javafx.beans.property.SimpleIntegerProperty import javafx.beans.property.SimpleObjectProperty import javafx.geometry.Pos import javafx.scene.image.Image class CounterView : View() {     override val root = BorderPane()     **val counter = SimpleIntegerProperty(1)**     **val imageObj = SimpleObjectProperty(Image("/cat.jpg"))**     **val source = imread("images/cat.jpg")**     init {         title = "Blur"         with (root) {             style {                 padding = box(20.px)             }             center {                 vbox(10.0) {                     alignment = Pos.CENTER                     label() {                         bind(counter)                         style { fontSize = 25.px }                     }                     imageview(imageObj) {                         fitWidth = 150.0                         fitHeight = 100.0                     }                     button("Click to increment") {                             action {                           increment()                             randomImage()                           }                     }                     button("Click to decrement {                           action {                          decrement()                          randomImage()                           }                     }                 }             }         }     }     fun blurImage() {       val result_mat = Mat()       blur(source, result_mat,          Size(counter.value.toDouble(),counter.value.toDouble()))       val mat_of_bytes = MatOfByte()       imencode(".jpg", result_mat, mat_of_bytes)       imageObj.value =          Image(java.io.ByteArrayInputStream(mat_of_bytes.toArray()))     }     fun increment() {         counter.value += 6     }     fun decrement() {         if(counter.value>6)           counter.value -= 6     } } class MyBlurApp : App(CounterView::class) object Blur {     @JvmStatic fun main(args: Array<String>) {       RT.loadLibrary(Core.NATIVE_LIBRARY_NAME)       Application.launch(MyBlurApp::class.java, *args)     } } As usual, Leiningen takes care of doing all the Kotlin compilation automatically for you on file change, and the blurring application appears as in Figure [1-49](#Fig49).![img/459821_1_En_1_Fig49_HTML.jpg](Images/459821_1_En_1_Fig49_HTML.jpg) Figure 1-49

模糊应用

当您点按增量按钮时，猫图像变得更加模糊，当您点按减量按钮时，它又变得更加平滑。

There are a few more tornadofx examples in the code samples along with this book, so do not hesitate to check them out. You will probably get more UI with OpenCV ideas; for example a drag-and-drop panel of images, when images can be blurred at will. Doesn’t sound that out of reach anymore, does it?![img/459821_1_En_1_Figa_HTML.jpg](Images/459821_1_En_1_Figa_HTML.jpg)

第一章充满了诀窍，从在 JavaVM 上用 OpenCV 创建一个小项目开始，逐步完成更复杂的图像操作示例，首先用 Java，然后最后享受 JavaVM 运行时环境，从而使用 Scala 工作，然后用富于表现力的 tornadofx 库编写 Kotlin 代码。

The door is now wide open to introduce the origami library, which is a Clojure wrapper for OpenCV. The environment will bring you even more concise code and more interactiveness to try new things and be creative. Time to get excited.

> 我对未来有一种普遍的兴奋感，但我还不知道那会是什么样子。但无论我做什么都会是。
> 
> 阿曼达·林德豪特